pipeline {
  agent {label 'Jagent'}

  parameters {
    // --- Git ---
    string(name: 'GIT_URL', defaultValue: 'https://github.com/SaifKbishi/devops_k8s_phase2.git', description: 'Git repository URL')
    string(name: 'BRANCH_NAME', defaultValue: 'jenkins', description: 'Branch to checkout')

    // --- Docker / Image ---
    string(name: 'DOCKERFILE', defaultValue: 'Dockerfile', description: 'Dockerfile path')
    string(name: 'DOCKERHUB_NAMESPACE', defaultValue: 'saifkbishi', description: 'Docker Hub namespace (username or org)')
    string(name: 'IMAGE_NAME', defaultValue: 'devops_k8s_phase2', description: 'Image name in Docker Hub')
    string(name: 'IMAGE_TAG', defaultValue: '', description: 'Optional. If empty, uses short commit SHA')

    // --- Test / App ---
    string(name: 'APP_PORT', defaultValue: '8080', description: 'Container port exposed by the app')
    string(name: 'HEALTHCHECK_PATH', defaultValue: '/', description: 'Path for HTTP healthcheck (e.g., /healthz)')

    // --- Kubernetes / Helm ---
    string(name: 'K8S_NAMESPACE', defaultValue: 'dev', description: 'Kubernetes namespace to deploy to')
    string(name: 'RELEASE_NAME', defaultValue: 'devops-k8s-phase2', description: 'Helm release name')
    string(name: 'CHART_NAME', defaultValue: 'app-chart', description: 'Name of the Helm chart (will be created if missing)')

    // --- Jenkins Credentials (IDs you create in Jenkins) ---
    string(name: 'DOCKERHUB_CREDENTIALS_ID', defaultValue: 'docker-hub-saif', description: 'Credentials ID: Docker Hub (username+password/token)')
    string(name: 'KUBECONFIG_CREDENTIALS_ID', defaultValue: 'kubeconfig-saif', description: 'Credentials ID: Kubernetes Kubeconfig (Secret file)')
  }

  environment {
    DOCKER_BUILDKIT = '1'   // Faster, modern Docker builds
  }

  stages {

    stage('Checkout') {
      steps {
        git branch: params.BRANCH_NAME, url: params.GIT_URL
      }
    }

    stage('Compute Image Tag') {
      steps {
        script {
          def shortSha = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
          env.EFFECTIVE_TAG = (params.IMAGE_TAG?.trim()) ? params.IMAGE_TAG.trim() : shortSha
          env.DOCKER_IMAGE = "${params.DOCKERHUB_NAMESPACE}/${params.IMAGE_NAME}:${env.EFFECTIVE_TAG}"
          env.CHART_DIR = "helm/${params.CHART_NAME}"
          echo "Docker image => ${env.DOCKER_IMAGE}"
          echo "Chart dir    => ${env.CHART_DIR}"
        }
      }
    }

    stage('Docker: Build & Push') {
      steps {
        withCredentials([usernamePassword(credentialsId: params.DOCKERHUB_CREDENTIALS_ID, usernameVariable: 'HUB_USER', passwordVariable: 'HUB_PASS')]) {
          sh '''#!/usr/bin/env bash
          set -euxo pipefail
          echo "$HUB_PASS" | docker login -u "$HUB_USER" --password-stdin
          cd app
          docker build -f "${DOCKERFILE}" -t "${DOCKER_IMAGE}" .
          docker push "${DOCKER_IMAGE}"
          docker logout || true
          '''
        }
      }
    }

    stage('Tests: Smoke (container)') {
      steps {
        sh '''#!/usr/bin/env bash
        set -euxo pipefail
        # Run container and verify HTTP endpoint responds
        cleanup() { docker rm -f app-test >/dev/null 2>&1 || true; }
        trap cleanup EXIT
        cleanup

        docker run -d --name app-test -p "${APP_PORT}:${APP_PORT}" "${DOCKER_IMAGE}"

        # Wait up to ~60s for readiness
        for i in $(seq 1 30); do
          if curl -fsS "http://127.0.0.1:${APP_PORT}${HEALTHCHECK_PATH}" >/dev/null; then
            echo "✅ App is responding"
            break
          fi
          sleep 2
        done

        # Final assert (fail if not healthy)
        curl -fsS "http://127.0.0.1:${APP_PORT}${HEALTHCHECK_PATH}" | head -c 500
        '''
      }
    }

    stage('Helm: Create/Update Chart') {
      steps {
        sh '''#!/usr/bin/env bash
        set -euxo pipefail
        mkdir -p helm
        if [ ! -d "${CHART_DIR}" ]; then
          echo "Creating Helm chart scaffold at ${CHART_DIR}"
          helm create "${CHART_DIR}"
        else
          echo "Helm chart already exists at ${CHART_DIR}"
        fi

        yfile="${CHART_DIR}/values.yaml"

        # Update image settings
        # (The default chart has .Values.image.repository/tag/pullPolicy)
        sed -i -E "s|(^|[[:space:]])repository:.*|\\1repository: ${DOCKERHUB_NAMESPACE}/${IMAGE_NAME}|" "$yfile"
        sed -i -E "s|(^|[[:space:]])tag:.*|\\1tag: ${EFFECTIVE_TAG}|" "$yfile"
        sed -i -E "s|(^|[[:space:]])pullPolicy:.*|\\1pullPolicy: IfNotPresent|" "$yfile"

        # Update service port (default Helm chart wires this into containerPort)
        sed -i -E "s|(^|[[:space:]])port: [0-9]+|\\1port: ${APP_PORT}|" "$yfile"

        # Make resources empty to avoid quota issues (optional)
        sed -i -E "s|resources:.*|resources: {}|" "$yfile" || true

        helm lint "${CHART_DIR}"
        '''
      }
    }

    stage('Helm: Package') {
      steps {
        sh '''#!/usr/bin/env bash
        set -euxo pipefail
        mkdir -p helm/packages
        helm package "${CHART_DIR}" -d helm/packages
        ls -la helm/packages
        '''
      }
    }

    stage('Helm: Deploy') {
      steps {
        withCredentials([file(credentialsId: params.KUBECONFIG_CREDENTIALS_ID, variable: 'KUBECONFIG_FILE')]) {
          withEnv(["KUBECONFIG=${KUBECONFIG_FILE}"]) {
            sh '''#!/usr/bin/env bash
            set -euxo pipefail
            # Use fullnameOverride to make resource names predictable
            helm upgrade --install "${RELEASE_NAME}" "${CHART_DIR}" \
              --namespace "${K8S_NAMESPACE}" \
              --create-namespace \
              --set image.repository="${DOCKERHUB_NAMESPACE}/${IMAGE_NAME}" \
              --set image.tag="${EFFECTIVE_TAG}" \
              --set service.port="${APP_PORT}" \
              --set fullnameOverride="${RELEASE_NAME}" \
              --wait --timeout 5m

            kubectl rollout status deploy/"${RELEASE_NAME}" -n "${K8S_NAMESPACE}" --timeout=120s
            kubectl get deploy,po,svc -n "${K8S_NAMESPACE}" -l app.kubernetes.io/instance="${RELEASE_NAME}" || true
            '''
          }
        }
      }
    }
  }

  post {
    success {
      echo "✅ Build ${env.BUILD_NUMBER} complete — image ${env.DOCKER_IMAGE} deployed as Helm release ${params.RELEASE_NAME} in ns ${params.K8S_NAMESPACE}"
    }
    always {
      sh 'docker image prune -f || true'
      archiveArtifacts artifacts: 'helm/packages/*.tgz', fingerprint: true, onlyIfSuccessful: true
    }
    failure {
      echo "❌ Pipeline failed — check logs above."
    }
  }
}
